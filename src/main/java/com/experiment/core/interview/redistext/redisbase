redis基础知识：https://www.cnblogs.com/hello-/articles/9599380.html
redis常见问题：缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级以及解决方案

缓存穿透：key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，
        从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，
        若黑客利用此漏洞进行攻击可能压垮数据库。
缓存击穿：key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，
        这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。
缓存雪崩：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，
        也会给后端系统(比如DB)带来很大压力。

一、缓存穿透解决方案
有很多种方法可以有效地解决缓存穿透问题：
    1、最常见的则是采用布隆过滤器：将所有可能存在的数据哈希到一个足够大的bitmap中，
            一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。
    2、 另外也有一个更为简单粗暴的方法（我们采用的就是这种）：
            如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，
            但它的过期时间会很短，最长不超过五分钟。

二、缓存击穿解决方案
key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。
使用互斥锁(mutex key)
    业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，
        而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，
        当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。
        SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果

二、缓存雪崩解决方案
大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。
这里分享一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，
这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。


常见问题
1.Redis支持的数据类型？
    string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。
2.什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？
    持久化：把内存中的数据存储到硬盘中，有效避免进程退出造成的数据丢失
    有两种方式RDB、AOF
        RDB：把当前进程的快照数据保存到硬盘中。
            优点：
                代表Redis某个时间点上的数据快照。
                用户备份，全量复制
                Redis加载RDB恢复数据远远快于AOF
            缺点：
                无法做到实时持久化，秒级持久化
                二进制格式，存在兼容问题
        AOF：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令达到恢复数据的目的
     两者对比：
         AOF 比 RDB 更新频率更高，优先使用AOF还原数据
         AOF 比 RDB更安全，更大
         RDB性能比AOF好
         优先加载AOF

3.Redis 有哪些架构模式？讲讲各自的特点
    单机版
    主从复制
    哨兵
    集群（proxy 型）
    集群（直连型）
4.使用过Redis分布式锁么，它是怎么实现的？
    1）获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。
    2）获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。
    3）释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。
5.使用过Redis做异步队列么，你是怎么用的？有什么缺点？
    Redis设计用来做缓存的，但是由于它自身的某种特性使得它可以用来做消息队列。
    做消息队列的其他特性例如FIFO（先入先出）也很容易实现，只需要一个list对象从头取数据，从尾部塞数据即可；
6.什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？
7.Redis常用命令
8.为什么Redis 单线程却能支撑高并发？
    Redis 对于 I/O 多路复用模块的设计非常简洁，通过宏保证了 I/O 多路复用模块在不同平台上都有着优异的性能，将不同的 I/O 多路复用函数封装成相同的 API 提供给上层使用。
    整个模块使 Redis 能以单进程运行的同时服务成千上万个文件描述符，避免了由于多进程应用的引入导致代码实现复杂度的提升，减少了出错的可能性。
9.说说Redis的内存淘汰策略
10.Redis的并发竞争问题如何解决?
    eg：像mysql一样插入出现并发插入，就会造成数据的不正确
    如何解决：
        （1）、利用redis自带的incr命令
        （2）、可以使用独占锁的方式，类似操作系统的mutex机制
        （3）、使用乐观锁的方式进行解决
        （4）、这个是针对客户端来的，在代码里要对redis操作的时候，针对同一key的资源，就先进行加锁
        （5）、利用redis的setnx实现内置的锁。