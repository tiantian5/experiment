数据库缓存更是在项目中必然会遇到的场景。而缓存一致性的保证
存储的速度是有区别的。缓存就是把低速存储的结果，临时保存在高速存储的技术。
数据库的请求80%请求会落到20%的热点数据上，在读多写少场景，增加一层缓存非常有助提升系统吞吐量和健壮性。
就会存在一种数据不一致的情况

有四种解决方案

第一种：通过key的过期时间，mysql更新时，redis不更新。这种方式实现简单，但不一致的时间会很长。
       如果读请求非常频繁，且过期时间比较长，则会产生很多长期的脏数据。

       优点：成本低、易于实现、出问题概率小
       缺点：完全依赖过期时间，时间太短容易缓存频繁失效，太长容易有长时间更新延迟

第二种：通过key的过期时间兜底，并且，在更新mysql时，同时更新redis。

       优点：更新延时小
       缺点：如果更新mysql成功，更新redis却失败，就退化到了方案一
            在高并发场景，业务server需要和mysql,redis同时进行连接。这样是损耗双倍的连接资源，容易造成连接数过多的问题。

第三种：增加消息队列，将redis更新操作交给消息中间件，由消息队列保证可靠性，再搭建一个消费服务(eg:mq)，来异步更新redis。

       优点：很多消息队列客户端还支持本地缓存发送，有效解决了方案二连接数过多的问题
            实现了逻辑上的解耦
            消息队列本身具有可靠性，通过手动提交等手段，redis可直接消费。
       缺点：时序性问题，写入数据频繁时，会出现一个属性进去消息队列的顺序发生变化导致数据不一致
            成本较高

第四种：订阅binlog来更新redis，把我们搭建的消费服务，作为mysql的一个slave，订阅binlog，解析出更新内容，再更新到redis。


一般情况，方案1够用。若延时要求高，直接选择方案4。如果是面试场景，从简单讲到复杂，面试官会一步一步追问，咱们就一点点推导，宾主尽欢
